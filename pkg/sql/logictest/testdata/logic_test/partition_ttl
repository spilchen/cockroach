# LogicTest: !local-prepared

subtest partition_ttl_basic_syntax

# Test basic partition TTL syntax
statement ok
CREATE TABLE events_partition_ttl (
  ts TIMESTAMPTZ NOT NULL,
  user_id UUID NOT NULL,
  payload STRING,
  PRIMARY KEY (ts, user_id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d',
  ttl_granularity = '1d',
  ttl_lookahead = '2d'
)

statement ok
DROP TABLE events_partition_ttl

subtest end

subtest partition_ttl_mode_validation

# Test that ttl_mode only accepts 'partition' or 'row'
statement error value of "ttl_mode" must be either 'partition' or 'row'
CREATE TABLE tbl_invalid_mode (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'invalid',
  ttl_column = 'ts',
  ttl_retention = '30d',
  ttl_granularity = '1d'
)

subtest end

subtest partition_ttl_retention_validation

# Test that ttl_retention must be a valid interval
statement error value of "ttl_retention" must be an interval
CREATE TABLE tbl_invalid_retention (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = 'invalid interval',
  ttl_granularity = '1d'
)

subtest end

subtest partition_ttl_granularity_validation

# Test that ttl_granularity must be a valid interval
statement error value of "ttl_granularity" must be an interval
CREATE TABLE tbl_invalid_granularity (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d',
  ttl_granularity = 'not an interval'
)

subtest end

subtest partition_ttl_lookahead_validation

# Test that ttl_lookahead must be a valid interval
statement error value of "ttl_lookahead" must be an interval
CREATE TABLE tbl_invalid_lookahead (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d',
  ttl_granularity = '1d',
  ttl_lookahead = 'bad interval'
)

subtest end

subtest partition_ttl_all_fields

# Test setting all partition TTL fields
statement ok
CREATE TABLE events_all_fields (
  ts TIMESTAMPTZ NOT NULL,
  user_id UUID NOT NULL,
  event_type STRING,
  PRIMARY KEY (ts, user_id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '1h',
  ttl_lookahead = '6h'
)

statement ok
DROP TABLE events_all_fields

subtest end

subtest partition_ttl_missing_column

# Test that ttl_column is required
statement error "ttl_column" must be set when using partition TTL
CREATE TABLE t_missing_column (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition'
)

subtest end

subtest partition_ttl_with_defaults

# Test that default values are applied for ttl_retention, ttl_granularity, and ttl_lookahead
statement ok
CREATE TABLE t_with_defaults (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  data STRING,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts'
)

statement ok
DROP TABLE t_with_defaults

subtest end

subtest partition_ttl_partial_defaults

# Test with some parameters specified and others using defaults
# When retention = '7d', granularity should default to a value < 7d
# (derived as retention/30 capped at 1h-1d, so likely 1h for 7d retention)
statement ok
CREATE TABLE t_partial_defaults (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d'
)

statement ok
DROP TABLE t_partial_defaults

subtest end

subtest partition_ttl_short_retention

# Test with very short retention (1 day)
# Granularity should be derived as < 1d (likely 1h)
# Lookahead should be 2x granularity (likely 2h)
statement ok
CREATE TABLE t_short_retention (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '1d'
)

statement ok
DROP TABLE t_short_retention

subtest end

subtest partition_ttl_long_retention

# Test with long retention (90 days)
# Granularity should be derived but capped at 1d
# Lookahead should be 2 days (2x granularity)
statement ok
CREATE TABLE t_long_retention (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '90d'
)

statement ok
DROP TABLE t_long_retention

subtest end

subtest partition_ttl_custom_granularity

# Test with custom granularity specified
# Lookahead should default to 2x granularity (4h)
statement ok
CREATE TABLE t_custom_granularity (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_granularity = '2h'
)

statement ok
DROP TABLE t_custom_granularity

subtest end

subtest partition_ttl_nonexistent_column

# Test that ttl_column must exist
statement error ttl_column "nonexistent" does not exist
CREATE TABLE t_nonexistent_column (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'nonexistent',
  ttl_retention = '30d',
  ttl_granularity = '1d',
  ttl_lookahead = '2d'
)

subtest end

subtest partition_ttl_wrong_column_type

# Test that ttl_column must be TIMESTAMP/TIMESTAMPTZ
statement error ttl_column "id" must be of type TIMESTAMP or TIMESTAMPTZ
CREATE TABLE t_wrong_type (
  ts TIMESTAMPTZ NOT NULL,
  id INT NOT NULL,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'id',
  ttl_retention = '30d',
  ttl_granularity = '1d',
  ttl_lookahead = '2d'
)

subtest end

subtest partition_ttl_nullable_column

# Test that ttl_column must be NOT NULL
statement error ttl_column "ts" must be NOT NULL
CREATE TABLE t_nullable (
  ts TIMESTAMPTZ,
  id INT NOT NULL,
  PRIMARY KEY (id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d',
  ttl_granularity = '1d',
  ttl_lookahead = '2d'
)

subtest end

subtest partition_ttl_not_first_pk_column

# Test that ttl_column must be the first column of the primary key
statement error ttl_column "ts" must be the first column of the primary key \(found "id" instead\)
CREATE TABLE t_not_first_pk (
  id INT NOT NULL,
  ts TIMESTAMPTZ NOT NULL,
  data TEXT,
  PRIMARY KEY (id, ts)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d'
)

subtest end

subtest partition_ttl_not_in_pk

# Test that ttl_column must be in the primary key
statement error ttl_column "ts" must be the first column of the primary key \(found "id" instead\)
CREATE TABLE t_not_in_pk (
  id INT NOT NULL,
  ts TIMESTAMPTZ NOT NULL,
  data TEXT,
  PRIMARY KEY (id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d'
)

subtest end

subtest partition_ttl_with_inbound_fk

# Test that partition TTL blocks creation of new inbound FKs
statement ok
CREATE TABLE ttl_parent (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d'
)

# Try to create a child table with FK to the partition TTL table
statement error cannot add foreign key constraint to table ttl_parent because it has partition TTL enabled
CREATE TABLE ttl_child (
  child_id INT PRIMARY KEY,
  parent_ts TIMESTAMPTZ NOT NULL,
  parent_id INT,
  FOREIGN KEY (parent_ts, parent_id) REFERENCES ttl_parent(ts, id)
)

statement ok
DROP TABLE ttl_parent

subtest end

subtest partition_ttl_granularity_exceeds_retention

# Test that granularity must be <= retention
statement error "ttl_granularity" \(2d\) must be less than or equal to "ttl_retention" \(1d\)
CREATE TABLE t_granularity_too_large (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '1d',
  ttl_granularity = '2d',
  ttl_lookahead = '1h'
)

subtest end

subtest partition_ttl_lookahead_too_small

# Test that lookahead must be >= granularity/2
statement error "ttl_lookahead" \(30m\) must be at least half of "ttl_granularity" \(2h\)
CREATE TABLE t_lookahead_too_small (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '2h',
  ttl_lookahead = '30m'
)

subtest end

subtest partition_ttl_zero_retention

# Test that retention must be > 0
statement error "ttl_retention" must be greater than zero
CREATE TABLE t_zero_retention (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '0s',
  ttl_granularity = '1d',
  ttl_lookahead = '2d'
)

subtest end

subtest partition_ttl_zero_granularity

# Test that granularity must be > 0
statement error "ttl_granularity" must be greater than zero
CREATE TABLE t_zero_granularity (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '0s',
  ttl_lookahead = '2d'
)

subtest end

subtest partition_ttl_zero_lookahead

# Test that lookahead must be > 0
statement error "ttl_lookahead" must be greater than zero
CREATE TABLE t_zero_lookahead (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '1d',
  ttl_lookahead = '0s'
)

subtest end

subtest partition_ttl_granularity_too_small

# Test that granularity must be at least 10 seconds
statement error partition granularity "9s" is too small; minimum granularity is 10 seconds
CREATE TABLE t_granularity_too_small (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '1d',
  ttl_granularity = '9s',
  ttl_lookahead = '1h'
)

subtest end

subtest partition_ttl_valid_edge_cases

# Test valid edge cases
# Granularity == Retention (1 partition)
statement ok
CREATE TABLE t_equal_granularity_retention (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '1d',
  ttl_granularity = '1d',
  ttl_lookahead = '12h'
)

statement ok
DROP TABLE t_equal_granularity_retention

# Lookahead == Granularity/2 (minimum allowed)
statement ok
CREATE TABLE t_minimum_lookahead (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '2h',
  ttl_lookahead = '1h'
)

statement ok
DROP TABLE t_minimum_lookahead

# Minimum granularity (10 seconds) should be allowed
statement ok
CREATE TABLE t_minimum_granularity (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '1h',
  ttl_granularity = '10s',
  ttl_lookahead = '30s'
)

statement ok
DROP TABLE t_minimum_granularity

subtest end

subtest partition_ttl_delete_params_create

# Test CREATE TABLE with delete_batch_size and delete_rate_limit
statement ok
CREATE TABLE t_create_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  data STRING,
  PRIMARY KEY (ts, id),
  FAMILY fam_0_ts_id_data (ts, id, data)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '1d',
  ttl_lookahead = '2d',
  ttl_delete_batch_size = 300,
  ttl_delete_rate_limit = 500
)

# Verify the values are persisted
query T
SELECT create_statement FROM [SHOW CREATE TABLE t_create_delete_params]
----
CREATE TABLE public.t_create_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING NULL,
  CONSTRAINT t_create_delete_params_pkey PRIMARY KEY (ts ASC, id ASC),
  FAMILY fam_0_ts_id_data (ts, id, data)
) PARTITION BY RANGE (ts) (
) WITH (ttl_mode = 'partition', ttl_column = 'ts', ttl_retention = '7d', ttl_granularity = '1d', ttl_lookahead = '2d', ttl_delete_batch_size = 300, ttl_delete_rate_limit = 500, schema_locked = true)
-- Warning: Partitioned table with no zone configurations.
;

statement ok
DROP TABLE t_create_delete_params

subtest end

subtest partition_ttl_alter_delete_params

# Test ALTER TABLE to set delete_batch_size and delete_rate_limit
statement ok
CREATE TABLE t_alter_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  data STRING,
  PRIMARY KEY (ts, id),
  FAMILY fam_0_ts (ts),
  FAMILY fam_1_id_data (id, data)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '30d'
)

# Alter delete_batch_size
statement ok
ALTER TABLE t_alter_delete_params SET (ttl_delete_batch_size = 500)

# Verify delete_batch_size was set
query T
SELECT create_statement FROM [SHOW CREATE TABLE t_alter_delete_params]
----
CREATE TABLE public.t_alter_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING NULL,
  CONSTRAINT t_alter_delete_params_pkey PRIMARY KEY (ts ASC, id ASC),
  FAMILY fam_0_ts (ts),
  FAMILY fam_1_id_data (id, data)
) PARTITION BY RANGE (ts) (
) WITH (ttl_mode = 'partition', ttl_column = 'ts', ttl_retention = '30d', ttl_granularity = '1h', ttl_lookahead = '2h', ttl_delete_batch_size = 500, schema_locked = true)
-- Warning: Partitioned table with no zone configurations.
;

# Alter delete_rate_limit
statement ok
ALTER TABLE t_alter_delete_params SET (ttl_delete_rate_limit = 1000)

# Verify delete_rate_limit was set
query T
SELECT create_statement FROM [SHOW CREATE TABLE t_alter_delete_params]
----
CREATE TABLE public.t_alter_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING NULL,
  CONSTRAINT t_alter_delete_params_pkey PRIMARY KEY (ts ASC, id ASC),
  FAMILY fam_0_ts (ts),
  FAMILY fam_1_id_data (id, data)
) PARTITION BY RANGE (ts) (
) WITH (ttl_mode = 'partition', ttl_column = 'ts', ttl_retention = '30d', ttl_granularity = '1h', ttl_lookahead = '2h', ttl_delete_batch_size = 500, ttl_delete_rate_limit = 1000, schema_locked = true)
-- Warning: Partitioned table with no zone configurations.
;

# Alter both at once
statement ok
ALTER TABLE t_alter_delete_params SET (ttl_delete_batch_size = 200, ttl_delete_rate_limit = 2000)

# Verify both values were updated
query T
SELECT create_statement FROM [SHOW CREATE TABLE t_alter_delete_params]
----
CREATE TABLE public.t_alter_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING NULL,
  CONSTRAINT t_alter_delete_params_pkey PRIMARY KEY (ts ASC, id ASC),
  FAMILY fam_0_ts (ts),
  FAMILY fam_1_id_data (id, data)
) PARTITION BY RANGE (ts) (
) WITH (ttl_mode = 'partition', ttl_column = 'ts', ttl_retention = '30d', ttl_granularity = '1h', ttl_lookahead = '2h', ttl_delete_batch_size = 200, ttl_delete_rate_limit = 2000, schema_locked = true)
-- Warning: Partitioned table with no zone configurations.
;

# Test negative values are rejected
statement error "ttl_delete_batch_size" must be at least 0
ALTER TABLE t_alter_delete_params SET (ttl_delete_batch_size = -1)

statement error "ttl_delete_rate_limit" must be at least 0
ALTER TABLE t_alter_delete_params SET (ttl_delete_rate_limit = -1)

# Test zero values are accepted (will use cluster defaults)
statement ok
ALTER TABLE t_alter_delete_params SET (ttl_delete_batch_size = 0)

# Verify delete_batch_size=0 removes it from WITH clause (uses cluster default)
query T
SELECT create_statement FROM [SHOW CREATE TABLE t_alter_delete_params]
----
CREATE TABLE public.t_alter_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING NULL,
  CONSTRAINT t_alter_delete_params_pkey PRIMARY KEY (ts ASC, id ASC),
  FAMILY fam_0_ts (ts),
  FAMILY fam_1_id_data (id, data)
) PARTITION BY RANGE (ts) (
) WITH (ttl_mode = 'partition', ttl_column = 'ts', ttl_retention = '30d', ttl_granularity = '1h', ttl_lookahead = '2h', ttl_delete_rate_limit = 2000, schema_locked = true)
-- Warning: Partitioned table with no zone configurations.
;

statement ok
ALTER TABLE t_alter_delete_params SET (ttl_delete_rate_limit = 0)

# Verify delete_rate_limit=0 removes it from WITH clause (uses cluster default)
query T
SELECT create_statement FROM [SHOW CREATE TABLE t_alter_delete_params]
----
CREATE TABLE public.t_alter_delete_params (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING NULL,
  CONSTRAINT t_alter_delete_params_pkey PRIMARY KEY (ts ASC, id ASC),
  FAMILY fam_0_ts (ts),
  FAMILY fam_1_id_data (id, data)
) PARTITION BY RANGE (ts) (
) WITH (ttl_mode = 'partition', ttl_column = 'ts', ttl_retention = '30d', ttl_granularity = '1h', ttl_lookahead = '2h', schema_locked = true)
-- Warning: Partitioned table with no zone configurations.
;

statement ok
DROP TABLE t_alter_delete_params

subtest end

subtest partition_ttl_automatic_partitioning_setup

# Test that tables with ttl_mode='partition' are automatically created with PARTITION BY RANGE.
# This allows the partition maintenance job to successfully add partitions to the table.

statement ok
CREATE TABLE t_auto_partitioning (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING,
  PRIMARY KEY (ts, id),
  FAMILY fam_0_ts_id_data (ts, id, data)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '1d',
  ttl_lookahead = '2d'
)

# Verify the table was created with PARTITION BY RANGE on the TTL column
# Check that SHOW CREATE TABLE includes the key partitioning and TTL information
query T
SELECT create_statement FROM [SHOW CREATE TABLE t_auto_partitioning]
----
CREATE TABLE public.t_auto_partitioning (
  ts TIMESTAMPTZ NOT NULL,
  id INT8 NOT NULL,
  data STRING NULL,
  CONSTRAINT t_auto_partitioning_pkey PRIMARY KEY (ts ASC, id ASC),
  FAMILY fam_0_ts_id_data (ts, id, data)
) PARTITION BY RANGE (ts) (
) WITH (ttl_mode = 'partition', ttl_column = 'ts', ttl_retention = '7d', ttl_granularity = '1d', ttl_lookahead = '2d', schema_locked = true)
-- Warning: Partitioned table with no zone configurations.
;

statement ok
DROP TABLE t_auto_partitioning

subtest end

subtest partition_ttl_schedule_cleanup_on_drop_table

# Test that partition TTL schedules are properly cleaned up when tables are dropped.
statement ok
CREATE TABLE tbl_schedule_cleanup (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  data STRING,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '7d',
  ttl_granularity = '1d',
  ttl_lookahead = '2d'
)

# Get the label for the scheduled job to verify it exists.
let $label_suffix
SELECT relname || ' [' || oid || ']' FROM pg_class WHERE relname = 'tbl_schedule_cleanup'

# Verify that a partition TTL schedule was created.
query I
SELECT count(1) FROM [SHOW SCHEDULES]
WHERE label = 'partition-ttl: $label_suffix'
----
1

# Drop the table.
statement ok
DROP TABLE tbl_schedule_cleanup

# Verify the schedule was deleted.
query I
SELECT count(1) FROM [SHOW SCHEDULES]
WHERE label = 'partition-ttl: $label_suffix'
----
0

subtest end

subtest partition_ttl_schedule_cleanup_on_drop_schema

# Create TTL on a different schema and ensure schedules are removed when dropped.
statement ok
CREATE SCHEMA drop_me_partition

statement ok
CREATE TABLE drop_me_partition.tbl (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '10d'
)

statement ok
CREATE TABLE drop_me_partition.tbl2 (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '10d'
)

let $label_suffix
SELECT relname || ' [' || oid || ']' FROM pg_class WHERE relname = 'tbl' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'drop_me_partition')

# Verify partition TTL schedule exists.
query I
SELECT count(1) FROM [SHOW SCHEDULES]
WHERE label = 'partition-ttl: $label_suffix'
----
1

# Drop the schema with CASCADE.
statement ok
DROP SCHEMA drop_me_partition CASCADE

# Verify the schedules were deleted.
query I
SELECT count(1) FROM [SHOW SCHEDULES]
WHERE label = 'partition-ttl: $label_suffix'
----
0

subtest end

subtest partition_ttl_schedule_cleanup_on_drop_database

# Create TTL on a different database and ensure schedules are removed when dropped.
statement ok
CREATE DATABASE drop_me_partition_db

statement ok
USE drop_me_partition_db

statement ok
CREATE TABLE tbl (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '10d'
)

statement ok
CREATE TABLE tbl2 (
  ts TIMESTAMPTZ NOT NULL,
  id INT,
  PRIMARY KEY (ts, id)
) WITH (
  ttl_mode = 'partition',
  ttl_column = 'ts',
  ttl_retention = '10d'
)

let $label_suffix
SELECT relname || ' [' || oid || ']' FROM pg_class WHERE relname = 'tbl'

# Verify partition TTL schedule exists.
query I
SELECT count(1) FROM [SHOW SCHEDULES]
WHERE label = 'partition-ttl: $label_suffix'
----
1

# Switch back to test database before dropping.
statement ok
USE test

# Drop the database.
statement ok
DROP DATABASE drop_me_partition_db

# Verify the schedules were deleted.
query I
SELECT count(1) FROM [SHOW SCHEDULES]
WHERE label = 'partition-ttl: $label_suffix'
----
0

subtest end
